//------------------------------
1 неделя
//------------------------------
При присваивании происходит полное копирование
Векторы можно сравнивать
map - словарь
Все встроенные типы в C++ можно сравнивать с помощью оператора сравнения

//------------------------------
2 неделя
//------------------------------
Параметры передаются в функцию по значению. Функция получает копию данных
Нельзя передавать результат функции по ссылке
std::boolalpha - выводит true/false вместо 1/0 (в коде: cout << std::boolalpha;)
string::size и string::length синонимы
steady_clock now   - получить текущее время

//----------
Контейнеры
//----------
vector
    std::begin - возвращает указатель на начало массива
    std::end   - указатель на воображаемый элемент за концом массива.
    Инициализация вектора векторов:
        std::vector<std::vector<int>> matrix (N, std::vector<int> (M));

map - словари
    Для каждого ключа string словарь хранит количество его вхождений int.
    Компилятор создаёт пару ключ-значение при обращении по ключу.

    Новая возможность в стандарте c++17:
        Старая запись:
            for (const auto& item : m) {
                item.first, item.second;
            }
        Новая запись:
            for (const auto& [key, value] : m) {
                key, value;
            }

    Метод .at(key) позволяет обратиться к элементу словаря без скобок [], которые меняют словарь

    Наполнение вектора по его ссылке:
        // Подготовка
        string bus;
        cin >> bus;
        map<string, vector<string>> buses_to_stops;
        int stop_count;
        cin >> stop_count;
        // Ввод вектора по ссылке
        vector<string>& stops = buses_to_stops[bus]; // С помощью ссылки дадим короткое название вектору со списком остановок данного автобуса. Ключ bus изначально отсутствовал в словаре, поэтому он автоматически добавится туда с пустым вектором в качестве значения
        stops.resize(stop_count);
        for (string& stop : stops) {
          cin >> stop;
        }

set - множества
    Можно присваивать множество вектору и наоборот.
    При присваивании из вектора в множество дубликаты элементов убираются, а оставшиеся элементы сортируются

//------------------------------
3 неделя
//------------------------------
Алгоритмы
    min, max, sort
    count(begin, end, Elem) - количество элементов в интервале
    count_if(begin, end, pred) - количество элементов, удавлетворяющих условию pred
    Лямбда функции:
       [t](int x) {return x > t}
       t - контекст, т.е. переменные, которые будут видны в этой ф-ии.
       x - принимаемый аргумент (вероятно, от итератора)
Модифицирующих range-based for:
    for (auto& I : v) { }
    for (const auto& I : v) { }
Функции стандартной библиотеки:
    lexicographical_compare - сравнивает соответственные пары элементов из двух последовательностей, ограниченных диапазонами [first1,last1) и [first2,last2);
    tolower - Функция выполняет преобразование прописных букв в строчные
    toupper - Функция выполняет преобразование строчных букв в прописные

for с набором значений
    for (int year : {1969, 1970}) {
        cout << person.GetFullName(year) << endl;
    }



Конструкторы
    Если указан параметризованный конструктор, то конструктор по умолчанию уже не будет создан автоматически

    При вызове, в параметрах функции, которая принимает объект какого-либо класса, для вызова конструктора этого класса необязательно указывать название класса со списком аргументов (если нужен параметризованный конструктор). Можно просто перечислить значения параметров для конструктора в фигурных скобках.
    Также, если функция возвращает объект класса, не обязаетльно в return для вызова конструктора класса (параметризованного или по умолчанию) указывать название класса. Достаточно указать пустые скобки для конструктора по умолчанию, либо скобки с параметрами для параметризованного конструктора.

    Если оператор переопределяется в классе он может быть константным. Если вне класса, в константности нет смысла.

    Для структур не нужнен конструктор по умолчанию. Для полей структуры можно указать значения по умолчанию при её определении через равно для любого поля. В дальнейшем при объявлении структуры можно не указывать значения всех или некоторых полей, они будут проинициализированы по умолчанию.

    Константный метод – это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект).
    Если  объект класса объявили как константный, можно будет вызывать только его константные методы.
    Конструктор не может быть константным.
    Константный объект класса может вызывать конструктор, который будет инициализировать все, некоторые или ни одну из переменных-членов!

    !   Делайте все ваши методы, которые не изменяют данные объекта класса, константными.

    Можно иметь константную и неконстантную версию одной и той же функции. Константная версия функции будет вызываться для константных объектов, а неконстантная версия будет вызываться для неконстантных объектов.

    Установка значений по умолчанию в конструкторе
        struct Duration {
            Duration(int h = 0, int m = 0) {
            ...
            }
        }

Ссылки и указатели (из обсуждения задачи)
    int x=1;
    int y = &x; //нельзя
    int* y = &x; // можно
    // если напечатать указатель
    cout << y << endl; // результат будет такого вида 0x7fff5fbff3b0 - просто адрес в памяти на первый байт из 4, который занимает integer.

    int& ref = x; // создадим ссылку
    //напечатаем переменную и ссылку на нее
    cout << x << " " << ref << endl; // результат: 1 1
    // потому что ref - это второе имя для переменной x, или иными словами - дополнительное имя для 4-х байт в памяти, которые выделены под переменную x.
    // если мы изменим указатель (если он не константный, как в нашем случае),
    ref = 2;
    // то изменится и сама переменная
    cout << x << " " << ref << endl; // результат 2 2

    // ССЫЛКИ
    int& ref2; // нельзя, ссылка должна быть сразу инициализирована; будет ошибка компиляции - нужно сразу назвать кому мы присваиваем второе имя, чей это псевдоним или никнейм. Это второе имя принадлежит только одной переменной, но у переменной может быть сколько угодно псевдонимов (т.е. ссылок), 

    int x2 = 2; // введем еще переменную
    ref = x2; // можно, так как это присваивание переменной x значение x2, но через второе имя (ссылку ref).
    // то есть когда мы объявляем ссылку (сразу проинициализировав), мы работаем уже с ссылкой как с той же переменной от которого мы создали ссылку

    // УКАЗАТЕЛИ
    int* y2; // можно, указатель может быть пустой
    int* y3 = NULL; // можно, указатель может быть пустой
    y2 = &x; // записываем адрес переменной x
    y2 = &x2; // записываем адрес переменной x2
    y3 = y2; // записываем адрес переменной x2, записанной в y2
    // а теперь внимание
    y2 = &ref; // записали адрес переменной x, так как ref - это ссылка (или второе имя) переменной x, то есть ref и x - это одна переменная, одна область памяти в 4 байта.

//------------------------------
4 неделя
//------------------------------
Explicit
    Чтобы обязать программиста писать при вызове метода название типов переменных, можно задать структуры с одним полем и использовать объявить метод, а котором на вход продаются такие структуры.
    Ещё лучше, если в каждой из таких структур будет описан explicit конструктор. Тогда не вызвать метод можно будет только с явным указанием типов аргументов, то есть названий этих структур. Вызов только по фигурным скобкам станет недоступным

Потоки ввода/вывода
    Основные
        istream - поток ввода
        ostream - поток вывода
        iostream - поток ввода/вывода

    Работа с файлами (наследники основных)
    #include <fstream>
        ifstream - чтение
        ofstream - запись
        fstream - чтение/запись
    #include <sstream>
        Класс stringstream, который позволяет связать поток ввода-вывода со строкой в памяти. Всё, что выводится в такой поток, добавляется в конец строки; всё, что считыватся из потока — извлекается из начала строки.
        stringstream ss("some text");  - класс входного\выходного потока
        istringstream ss("some text"); - класс входного потока
        ostringstream ss("some text"); - класс выходного потока

    >> - оператор ввода
    getline считывание построчно. Перевод строки не считывается в переменную.

    Проверка открыт ли поток
        ifstream input("hello.txt");
        cout << input.is_open();         // вернёт true/false
        if (input) { cout >> "opened" } // можно привести поток к типу bool

    Чтение через разделитель
        getline(imput, var, '-');   // считать из input в переменную var до дефиса
        input.ignore(1);            // игнорировать некоторое кол-во символов

    Поток вывода
        ofstream output("out.txt");
        ofstream output("out.txt", ios::app);   // дозапись после нового открытия файла

    Потоковые манипуляторы
    #include <iomanip>
        fixed           - выводить числа с фиксированной точностью
        setprecision(n) - установить кол-во знаков n после запятой
        setw(n)         - установить размер поля = n, для одной следующей переменной
        left            - выровнять значения по левому краю поля, установленного в setw
        setfill('.')    - установить заполнитель вместо пробелов (тип char), для всех последующих выводов в этот поток
        Использование:
            #include <iomanip>
            cout << fixed << setprecision(2); // Установить вывод двух знаков после запятой

Перегрузка операторов
    Чтобы с классом было удобно работать, можно перегрузить для него операторы.
    При перегрузке указываем один, либо два (см. ниже) аргумента LHS(left hand side) и RHS(right hand side), если у аргумента два оператора.
    Если перегрузка описывается снаружи класса, то указывается два параметра, если внутри, то только один. Вторым является объект класса, чей оператор вызывается.
    Если у аргумента один оператор, то аргумент будет один.
        ??? operator ???(???)
        bool operator <(const TObj& lhs,
                        const TObj& rhs)
        TObj operator +(const TObj& lhs,
                        const TObj& rhs)

    // Оператор вывода в поток
    // переопределение <<, в параметрах поток в который выводим и объект который выводим
    istream& operator<<(ostream& s, const Obj& duration) {...}
    
    // Оператор ввода из потока
    istream& operator>>(istream& s, Obj& o) {...}

    ! Важно для операторов ввода вывода возвращать ссылку на поток.
    Это поможет зацепить следующий вввод вывод в записи вида cout << "Hello" << "world"

    // Оператор сложения для класса Duration
    Duration operator+(const Duration& lhs, const Duration& rhs) {
        return Duration(lhs.hours + rhs.hour, lhs.min + rhs.min);
    }

    // Оператор маньше
    bool operator<(const Duration& lhs, const Duration& rhs) {
        if (lhs.hour == rhs.hour) {
            return lhs.min < rhs.min;
        }
        return lhs.hour < rhs.hour;
    }

Исключения
    #include <exception>
    exception - класс, цель которого - служить базовым классом в иерархии исключений
    Иерархия классов для разных видов ошибок:
        std::exception  <-- std::logic_error    <-- std::invalid_argument
                                                    std::domain_error (для ситуаций, когда входные данные находятся за пределами домена, в котором определена операция.)
                            std::runtime_error  <-- std::range_error
                                                    std::overflow_error
                                                    std::underflow_error
                                                    std::system_error
    throw exeption(); // бросить исключение
    Все исключения наследуются от класса exception. Поэтому можно их ловить по exception& ссылкам.
    runtime_error и остальные подклассы exeption могут перехватываться отдельно. Например:
        catch (std::runtime_error& e) будет перехватывать все исключения из поддерева std::runtime_error, позволяя всем другим проходить (и летать дальше по стеку вызовов).
    Исключеня можно бросать из вложенных функций.

    Обработчик ошибок
        try {
            // опасный код ниже
            if (всё плохо) {
                stringstream ss;
                ss << "expected / , but has: " << bad_string_var; // Добавляем к сообщению строку.
                                                                  // Если символ, можно сделат char(stream.peek())
                throw runtime_error(ss.str);                      // Строка в качестве параметра
            }
        } catch (exception& ex) {
            // обработка ошибки
            обработка ошибки
            cout << "exception happens: " << ex.what(); // Метод what() выдаст текст ошибки применённый к объекту класса exeption
        }


//-----------------------
Общее
//-----------------------
Инверсия знака допустима следующей записью:
    numerator = -numerator;