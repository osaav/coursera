//------------------------------
1 неделя
//------------------------------
При присваивании происходит полное копирование
Векторы можно сравнивать
map - словарь
Все встроенные типы в C++ можно сравнивать с помощью оператора сравнения

//------------------------------
2 неделя
//------------------------------
Параметры передаются в функцию по значению. Функция получает копию данных
Нельзя передавать результат функции по ссылке
std::boolalpha - выводит true/false вместо 1/0 (в коде: cout << std::boolalpha;)
string::size и string::length синонимы
steady_clock now   - получить текущее время

//----------
Контейнеры
//----------
vector
    std::begin - возвращает указатель на начало массива
    std::end   - указатель на воображаемый элемент за концом массива.

map - словари
    Для каждого ключа string словарь хранит количество его вхождений int.
    Компилятор создаёт пару ключ-значение при обращении по ключу.

    Новая возможность в стандарте c++17:
        Старая запись:
            for (const auto& item : m) {
                item.first, item.second;
            }
        Новая запись:
            for (const auto& [key, value] : m) {
                key, value;
            }

    Наполнение вектора по его ссылке:
        // Подготовка
        string bus;
        cin >> bus;
        map<string, vector<string>> buses_to_stops;
        int stop_count;
        cin >> stop_count;
        // Ввод вектора по ссылке
        vector<string>& stops = buses_to_stops[bus]; // С помощью ссылки дадим короткое название вектору со списком остановок данного автобуса. Ключ bus изначально отсутствовал в словаре, поэтому он автоматически добавится туда с пустым вектором в качестве значения
        stops.resize(stop_count);
        for (string& stop : stops) {
          cin >> stop;
        }

set - множества
    Можно присваивать множество вектору и наоборот.
    При присваивании из вектора в множество дубликаты элементов убираются, а оставшиеся элементы сортируются

//------------------------------
3 неделя
//------------------------------
Алгоритмы
    min, max, sort
    count(begin, end, Elem) - количество элементов в интервале
    count_if(begin, end, pred) - количество элементов, удавлетворяющих условию pred
    Лямбда функции:
       [t](int x) {return x > t}
       t - контекст, т.е. переменные, которые будут видны в этой ф-ии.
       x - принимаемый аргумент (вероятно, от итератора)
Модифицирующих range-based for:
    for (auto& I : v) { }
    for (const auto& I : v) { }
Функции стандартной библиотеки:
    lexicographical_compare - сравнивает соответственные пары элементов из двух последовательностей, ограниченных диапазонами [first1,last1) и [first2,last2);
    tolower - Функция выполняет преобразование прописных букв в строчные
    toupper - Функция выполняет преобразование строчных букв в прописные

for с набором значений
    for (int year : {1969, 1970}) {
        cout << person.GetFullName(year) << endl;
    }



Конструкторы
    Если указан параметризованный конструктор, то конструктор по умолчанию уже не будет создан автоматически

    При вызове, в параметрах функции, которая принимает объект какого-либо класса, для вызова конструктора этого класса необязательно указывать название класса со списком аргументов (если нужен параметризованный конструктор). Можно просто перечислить значения параметров для конструктора в фигурных скобках.
    Также, если функция возвращает объект класса, не обязаетльно в return для вызова конструктора класса (параметризованного или по умолчанию) указывать название класса. Достаточно указать пустые скобки для конструктора по умолчанию, либо скобки с параметрами для параметризованного конструктора.

    Для структур не нужнен конструктор по умолчанию. Для полей структуры можно указать значения по умолчанию при её определении через равно для любого поля. В дальнейшем при объявлении структуры можно не указывать значения всех или некоторых полей, они будут проинициализированы по умолчанию.

    Константный метод – это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект).
    Если  объект класса объявили как константный, можно будет вызывать только его константные методы.
    Конструктор не может быть константным.
    Константный объект класса может вызывать конструктор, который будет инициализировать все, некоторые или ни одну из переменных-членов!

    !   Делайте все ваши методы, которые не изменяют данные объекта класса, константными.

    Можно иметь константную и неконстантную версию одной и той же функции. Константная версия функции будет вызываться для константных объектов, а неконстантная версия будет вызываться для неконстантных объектов.

Ссылки и указатели (из обсуждения задачи)
    int x=1;
    int y = &x; //нельзя
    int* y = &x; // можно
    // если напечатать указатель
    cout << y << endl; // результат будет такого вида 0x7fff5fbff3b0 - просто адрес в памяти на первый байт из 4, который занимает integer.

    int& ref = x; // создадим ссылку
    //напечатаем переменную и ссылку на нее
    cout << x << " " << ref << endl; // результат: 1 1
    // потому что ref - это второе имя для переменной x, или иными словами - дополнительное имя для 4-х байт в памяти, которые выделены под переменную x.
    // если мы изменим указатель (если он не константный, как в нашем случае),
    ref = 2;
    // то изменится и сама переменная
    cout << x << " " << ref << endl; // результат 2 2

    // ССЫЛКИ
    int& ref2; // нельзя, ссылка должна быть сразу инициализирована; будет ошибка компиляции - нужно сразу назвать кому мы присваиваем второе имя, чей это псевдоним или никнейм. Это второе имя принадлежит только одной переменной, но у переменной может быть сколько угодно псевдонимов (т.е. ссылок), 

    int x2 = 2; // введем еще переменную
    ref = x2; // можно, так как это присваивание переменной x значение x2, но через второе имя (ссылку ref).
    // то есть когда мы объявляем ссылку (сразу проинициализировав), мы работаем уже с ссылкой как с той же переменной от которого мы создали ссылку

    // УКАЗАТЕЛИ
    int* y2; // можно, указатель может быть пустой
    int* y3 = NULL; // можно, указатель может быть пустой
    y2 = &x; // записываем адрес переменной x
    y2 = &x2; // записываем адрес переменной x2
    y3 = y2; // записываем адрес переменной x2, записанной в y2
    // а теперь внимание
    y2 = &ref; // записали адрес переменной x, так как ref - это ссылка (или второе имя) переменной x, то есть ref и x - это одна переменная, одна область памяти в 4 байта.

//------------------------------
4 неделя
//------------------------------
Explicit
    Чтобы обязать программиста писать при вызове метода название типов переменных, можно задать структуры с одним полем и использовать объявить метод, а котором на вход продаются такие структуры.
    Ещё лучше, если в каждой из таких структур будет описан explicit конструктор. Тогда не вызвать метод можно будет только с явным указанием типов аргументов, то есть названий этих структур. Вызов только по фигурным скобкам станет недоступным

Потоки ввода/вывода
    Основные
        istream - поток ввода
        ostream - поток вывода
        iostream - поток ввода/вывода

    Работа с файлами (наследники основных)
        ifstream - чтение
        ofstream - запись
        fstream - чтение/запись

    >> - оператор ввода
    getline считывание построчно. Перевод строки не считывается в переменную.
